<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>CryptoJS Test Suite</title>

        <!-- CryptoJS -->
        <script src="../src/core.js"></script>
        <script src="../src/base64.js"></script>
        <script src="../src/formatter_base.js"></script>
        <script src="../src/hash_base.js"></script>
        <script src="../src/md5.js"></script>
        <script src="../src/sha1.js"></script>
        <script src="../src/sha256.js"></script>
        <script src="../src/hmac.js"></script>
        <script src="../src/pbkdf2.js"></script>
        <script src="../src/evp-key-derivation.js"></script>
        <script src="../src/cipher_base.js"></script>
        <script src="../src/marc4.js"></script>

        <!-- YUI -->
        <script src="http://yui.yahooapis.com/3.3.0/build/yui/yui-min.js"></script>

        <!-- Tests -->
        <script type="text/javascript">
            YUI().use('test', 'console', function (Y) {
                // Shortcut
                var C = CryptoJS;

                // Augment WordArray with "stringify" for testing
                C.lib.WordArray.stringify = function () {
                    var formattedWords = [];
                    for (var i = 0; i < this.words.length; i++) {
                        formattedWords[i] = '0x' + (this.words[i] >>> 0).toString(16);
                    }

                    return '{words:[' + formattedWords.join(',') + '],sigBytes:' + this.sigBytes + '}';
                };

                // CryptoJS test suite
                var cryptoJsTestSuite = new Y.Test.Suite('CryptoJS');

                // BaseObj test suite
                var baseObjTestSuite = new Y.Test.Suite('BaseObj');
                cryptoJsTestSuite.add(baseObjTestSuite);

                // BaseObj.extend test case
                baseObjTestSuite.add(new Y.Test.Case({
                    name: 'extend()',

                    setUp: function () {
                        this.data = {};

                        this.data.myObjOverrides = {
                            abc: 'abc',
                            toString: function () {}
                        };

                        this.data.myObj = C.lib.BaseObj.extend(this.data.myObjOverrides);
                    },

                    testBaseObjExtendInheritance: function () {
                        Y.Assert.areEqual(C.lib.BaseObj.extend, this.data.myObj.extend);
                        Y.Assert.isFalse(this.data.myObj.hasOwnProperty('extend'));
                    },

                    testBaseObjExtendSuper: function () {
                        Y.Assert.areEqual(C.lib.BaseObj, this.data.myObj.$super);
                    },

                    testBaseObjExtendOverrides: function () {
                        // abc
                        Y.Assert.areEqual(this.data.myObjOverrides.abc, this.data.myObj.abc);
                        Y.Assert.isTrue(this.data.myObj.hasOwnProperty('abc'));

                        // toString
                        Y.Assert.areEqual(this.data.myObjOverrides.toString, this.data.myObj.toString);
                        Y.Assert.isTrue(this.data.myObj.hasOwnProperty('toString'));
                    }
                }));

                // BaseObj.create test case
                baseObjTestSuite.add(new Y.Test.Case({
                    name: 'create()',

                    setUp: function () {
                        this.data = {};

                        this.data.MyObj = C.lib.BaseObj.extend({
                            init: function (myArg) {
                                this.initFired = true;
                                this.myArg = myArg;
                            }
                        });

                        this.data.myObj = this.data.MyObj.create('myArg');
                    },

                    testBaseObjCreateInheritance: function () {
                        // from MyObj
                        Y.Assert.areEqual(this.data.MyObj.init, this.data.myObj.init);
                        Y.Assert.isFalse(this.data.myObj.hasOwnProperty('init'));

                        // from BaseObj
                        Y.Assert.areEqual(C.lib.BaseObj.extend, this.data.myObj.extend);
                        Y.Assert.isFalse(this.data.myObj.hasOwnProperty('extend'));
                    },

                    testBaseObjCreateSuper: function () {
                        Y.Assert.areEqual(this.data.MyObj, this.data.myObj.$super);
                    },

                    testBaseObjCreateInit: function () {
                        Y.Assert.isTrue(this.data.myObj.initFired);
                        Y.Assert.areEqual('myArg', this.data.myObj.myArg);
                    }
                }));

                // BaseObj.clone test case
                baseObjTestSuite.add(new Y.Test.Case({
                    name: 'clone()',

                    setUp: function () {
                        this.data = {};

                        this.data.myObj = C.lib.BaseObj.extend({
                            abc: 'abc'
                        });

                        this.data.myObjClone = this.data.myObj.clone();
                    },

                    testBaseObjCloneDistinct: function () {
                        Y.Assert.areNotEqual(this.data.myObj, this.data.myObjClone);
                    },

                    testBaseObjCloneCopy: function () {
                        Y.Assert.areEqual(this.data.myObj.abc, this.data.myObjClone.abc);
                    },

                    testBaseObjCloneIndependent: function () {
                        this.data.myObj.abc = 'xyz';

                        Y.Assert.areNotEqual(this.data.myObj.abc, this.data.myObjClone.abc);
                    }
                }));

                // Hex test case
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'Hex',

                    testHexEncode: function () {
                        Y.Assert.areEqual('48656c6c6f2c20576f726c6421', C.enc.Hex.encode(C.lib.WordArray.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13)));
                    },

                    testHexDecode: function () {
                        Y.Assert.areEqual('{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}', C.enc.Hex.decode('48656c6c6f2c20576f726c6421').stringify());
                    }
                }));

                // Latin1 test case
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'Latin1',

                    testLatin1Encode: function () {
                        Y.Assert.areEqual('Hello, World!', C.enc.Latin1.encode(C.lib.WordArray.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13)));
                    },

                    testLatin1Decode: function () {
                        Y.Assert.areEqual('{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}', C.enc.Latin1.decode('Hello, World!').stringify());
                    }
                }));

                // Utf8 test case
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'Utf8',

                    testUtf8Encode: function () {
                        Y.Assert.areEqual('$', C.enc.Utf8.encode(C.lib.WordArray.create([0x24000000], 1)));
                        Y.Assert.areEqual('¢', C.enc.Utf8.encode(C.lib.WordArray.create([0xc2a20000], 2)));
                        Y.Assert.areEqual('€', C.enc.Utf8.encode(C.lib.WordArray.create([0xe282ac00], 3)));
                        Y.Assert.areEqual('𤭢', C.enc.Utf8.encode(C.lib.WordArray.create([0xf0a4ada2], 4)));
                    },

                    testUtf8Decode: function () {
                        Y.Assert.areEqual('{words:[0x24000000],sigBytes:1}', C.enc.Utf8.decode('$').stringify());
                        Y.Assert.areEqual('{words:[0xc2a20000],sigBytes:2}', C.enc.Utf8.decode('¢').stringify());
                        Y.Assert.areEqual('{words:[0xe282ac00],sigBytes:3}', C.enc.Utf8.decode('€').stringify());
                        Y.Assert.areEqual('{words:[0xf0a4ada2],sigBytes:4}', C.enc.Utf8.decode('𤭢').stringify());
                    }
                }));

                // Base64 test case
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'Base64',

                    testBase64Encode: function () {
                        Y.Assert.areEqual('', C.enc.Base64.encode(C.lib.WordArray.create([0x666f6f62, 0x61720000], 0)));
                        Y.Assert.areEqual('Zg==', C.enc.Base64.encode(C.lib.WordArray.create([0x666f6f62, 0x61720000], 1)));
                        Y.Assert.areEqual('Zm8=', C.enc.Base64.encode(C.lib.WordArray.create([0x666f6f62, 0x61720000], 2)));
                        Y.Assert.areEqual('Zm9v', C.enc.Base64.encode(C.lib.WordArray.create([0x666f6f62, 0x61720000], 3)));
                        Y.Assert.areEqual('Zm9vYg==', C.enc.Base64.encode(C.lib.WordArray.create([0x666f6f62, 0x61720000], 4)));
                        Y.Assert.areEqual('Zm9vYmE=', C.enc.Base64.encode(C.lib.WordArray.create([0x666f6f62, 0x61720000], 5)));
                        Y.Assert.areEqual('Zm9vYmFy', C.enc.Base64.encode(C.lib.WordArray.create([0x666f6f62, 0x61720000], 6)));
                        Y.Assert.areEqual('Pj4+Pz8/Pj4+Pz8/PS8r', C.enc.Base64.encode(C.lib.WordArray.create([0x3e3e3e3f, 0x3f3f3e3e, 0x3e3f3f3f, 0x3d2f2b00], 15)));
                    },

                    testBase64UrlSafeEncode: function () {
                        Y.Assert.areEqual('Zg', C.enc.Base64.UrlSafe.encode(C.lib.WordArray.create([0x666f6f62, 0x61720000], 1)));
                        Y.Assert.areEqual('Pj4-Pz8_Pj4-Pz8_PS8r', C.enc.Base64.UrlSafe.encode(C.lib.WordArray.create([0x3e3e3e3f, 0x3f3f3e3e, 0x3e3f3f3f, 0x3d2f2b00], 15)));
                    },

                    testBase64Decode: function () {
                        Y.Assert.areEqual('{words:[],sigBytes:0}', C.enc.Base64.decode('').stringify());
                        Y.Assert.areEqual('{words:[0x66000000],sigBytes:1}', C.enc.Base64.decode('Zg==').stringify());
                        Y.Assert.areEqual('{words:[0x666f0000],sigBytes:2}', C.enc.Base64.decode('Zm8=').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f00],sigBytes:3}', C.enc.Base64.decode('Zm9v').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f62],sigBytes:4}', C.enc.Base64.decode('Zm9vYg==').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f62,0x61000000],sigBytes:5}', C.enc.Base64.decode('Zm9vYmE=').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f62,0x61720000],sigBytes:6}', C.enc.Base64.decode('Zm9vYmFy').stringify());
                        Y.Assert.areEqual('{words:[0x3e3e3e3f,0x3f3f3e3e,0x3e3f3f3f,0x3d2f2b00],sigBytes:15}', C.enc.Base64.decode('Pj4+Pz8/Pj4+Pz8/PS8r').stringify());
                    },

                    testBase64UrlSafeDecode: function () {
                        Y.Assert.areEqual('{words:[0x66000000],sigBytes:1}', C.enc.Base64.UrlSafe.decode('Zg').stringify());
                        Y.Assert.areEqual('{words:[0x3e3e3e3f,0x3f3f3e3e,0x3e3f3f3f,0x3d2f2b00],sigBytes:15}', C.enc.Base64.UrlSafe.decode('Pj4-Pz8_Pj4-Pz8_PS8r').stringify());
                    }
                }));

                // WordArray test case
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'WordArray',

                    testWordArrayInit0: function () {
                        var wordArray = C.lib.WordArray.create();

                        Y.Assert.areEqual('{words:[],sigBytes:0}', wordArray.stringify());
                    },

                    testWordArrayInit1: function () {
                        var wordArray = C.lib.WordArray.create([0x12345678]);

                        Y.Assert.areEqual('{words:[0x12345678],sigBytes:4}', wordArray.stringify());
                    },

                    testWordArrayInit2: function () {
                        var wordArray = C.lib.WordArray.create([0x12345678], 2);

                        Y.Assert.areEqual('{words:[0x12345678],sigBytes:2}', wordArray.stringify());
                    },

                    testWordArrayToString: function () {
                        Y.Assert.areEqual('e282ac', C.lib.WordArray.create([0xe282ac00], 3).toString(C.enc.Hex));
                        Y.Assert.areEqual('\xe2\x82\xac', C.lib.WordArray.create([0xe282ac00], 3).toString(C.enc.Latin1));
                        Y.Assert.areEqual('€', C.lib.WordArray.create([0xe282ac00], 3).toString(C.enc.Utf8));

                        Y.Assert.areEqual('e282ac', C.lib.WordArray.Hex.create([0xe282ac00], 3).toString());
                        Y.Assert.areEqual('\xe2\x82\xac', C.lib.WordArray.Latin1.create([0xe282ac00], 3).toString());
                        Y.Assert.areEqual('€', C.lib.WordArray.Utf8.create([0xe282ac00], 3).toString());
                    },

                    testWordArrayConcat: function () {
                        Y.Assert.areEqual('{words:[0x61626361,0x62630000],sigBytes:6}', C.lib.WordArray.create([0x61626300], 3).concat(C.lib.WordArray.create([0x61626300], 3)).stringify());
                    },

                    testWordArrayClamp: function () {
                        var wordArray = C.lib.WordArray.create([0x61626361, 0x62630000], 3);
                        wordArray.clamp();

                        Y.Assert.areEqual('{words:[0x61626300],sigBytes:3}', wordArray.stringify());
                    },

                    testWordArrayRandom: function () {
                        Y.Assert.areNotEqual(C.lib.WordArray.random(2).stringify(), C.lib.WordArray.random(2).stringify());
                        Y.Assert.areEqual(8, C.lib.WordArray.random(2).sigBytes);
                    }
                }));

                // Event test case
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'Event',

                    testEventSubscribeFire: function () {
                        // Callback
                        var callbackFired = false;
                        function callback() {
                            callbackFired = true;
                        }

                        // Subscribe
                        var myEvent = C.lib.Event.create();
                        myEvent.subscribe(callback);

                        // Fire
                        myEvent.fire();

                        // Test fired
                        Y.Assert.isTrue(callbackFired);
                    }
                }));

                // Hash formatter
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'HashFormatter',

                    testHashFormatterToString: function () {
                        var hash = C.MD5.compute('');

                        Y.Assert.areEqual(C.enc.Latin1.decode('Salted__').concat(hash.salt).concat(hash.rawData).toString(C.enc.Hex), hash.toString());
                    },

                    testHashFormatterFromString: function () {
                        var saltedHash   = C.hash.Formatter.fromString('53616c7465645f5f0123456789abcdef0123456789abcdef0123456789abcdef');
                        var unsaltedHash = C.hash.Formatter.fromString('0123456789abcdef0123456789abcdef');

                        Y.Assert.areEqual('{words:[0x1234567,0x89abcdef,0x1234567,0x89abcdef],sigBytes:16}', saltedHash.rawData.stringify());
                        Y.Assert.areEqual('{words:[0x1234567,0x89abcdef],sigBytes:8}', saltedHash.salt.stringify());

                        Y.Assert.areEqual('{words:[0x1234567,0x89abcdef,0x1234567,0x89abcdef],sigBytes:16}', unsaltedHash.rawData.stringify());
                        Y.Assert.isUndefined(unsaltedHash.salt);
                    }
                }));

                // Hash base
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'HashBase',

                    testHashBaseUpdate: function () {
                        var expectedHash = C.MD5.compute('12345678901234567890123456789012345678901234567890123456789012345678901234567890', { salt: null }).toString();

                        var md5 = C.MD5.create({ salt: null });
                        md5.update('1234567890123456789012345678901234567890');
                        md5.update('12345678901234567890');
                        var actualHash = md5.compute('12345678901234567890').toString();

                        Y.Assert.areEqual(expectedHash, actualHash);
                    },

                    testHashBaseCustomSalt: function () {
                        var customSalt = C.lib.WordArray.create([0x01234567, 0x89abcdef]);

                        var rawHash = C.MD5.create({ salt: null }).update(customSalt).compute('').rawData;
                        var expectedHash = C.enc.Latin1.decode('Salted__').concat(customSalt).concat(rawHash).toString(C.enc.Hex);

                        var actualHash = C.MD5.compute('', { salt: customSalt }).toString();

                        Y.Assert.areEqual(actualHash, expectedHash);
                    },

                    testHashBaseRandomSalt: function () {
                        Y.Assert.areNotEqual(C.MD5.compute().salt.stringify(), C.MD5.compute().salt.stringify());
                    },

                    testHashBaseBeforeComputeSalter: function () {
                        var customSalt = C.lib.WordArray.create([0x01234567, 0x89abcdef]);

                        var beforeComputeSalter = function () {
                            var hasher = this;

                            // Shortcut
                            var cfg = hasher.cfg;

                            // Use random salt if not defined
                            if ( ! cfg.salt) {
                                cfg.salt = WordArray_Hex.random(2);
                            }

                            // Salt
                            hasher.beforeCompute.subscribe(function () {
                                hasher.update(cfg.salt);
                            });
                        };

                        var rawHash = C.MD5.create({ salt: null }).update('').compute(customSalt).rawData;
                        var expectedHash = C.enc.Latin1.decode('Salted__').concat(customSalt).concat(rawHash).toString(C.enc.Hex);

                        var actualHash = C.MD5.compute('', { salt: customSalt, salter: beforeComputeSalter }).toString();

                        Y.Assert.areEqual(expectedHash, actualHash);
                    },

                    testHashBaseAfterComputeSalter: function () {
                        var customSalt = C.lib.WordArray.create([0x01234567, 0x89abcdef]);

                        var afterComputeSalter = function () {
                            var hasher = this;

                            // Shortcut
                            var cfg = hasher.cfg;

                            // Use random salt if not defined
                            if ( ! cfg.salt) {
                                cfg.salt = WordArray_Hex.random(2);
                            }

                            // Salt
                            hasher.afterCompute.subscribe(function () {
                                var newHasher = hasher.$super.create({ salt: null });
                                hasher.hash = newHasher.update(cfg.salt).compute(hasher.hash).rawData;
                            });
                        };

                        var md5 = C.MD5.create({ salt: null });
                        var intermediate = md5.compute('').rawData;
                        var rawHash = md5.update(customSalt).compute(intermediate).rawData
                        var expectedHash = C.enc.Latin1.decode('Salted__').concat(customSalt).concat(rawHash).toString(C.enc.Hex);

                        var actualHash = C.MD5.compute('', { salt: customSalt, salter: afterComputeSalter }).toString();

                        Y.Assert.areEqual(expectedHash, actualHash);
                    },

                    testHashBaseCustomFormatter: function () {
                        var customSalt = C.lib.WordArray.create([0x01234567, 0x89abcdef]);

                        var customFormatter = C.hash.Formatter.extend({
                            toString: function () {
                                var hashStr = '{ hash: "' + this.rawData.toString(C.enc.Hex) + '"';
                                if (this.salt) {
                                    hashStr += ', salt: "' + this.salt.toString(C.enc.Hex) + '"';
                                }
                                hashStr += ' }';

                                return hashStr;
                            }
                        });

                        var hash = C.MD5.compute('', { salt: customSalt });
                        var expectedHash = '{ hash: "' + hash.rawData.toString(C.enc.Hex) + '", salt: "' + hash.salt.toString(C.enc.Hex) + '" }';

                        var actualHash = C.MD5.compute('', { formatter: customFormatter, salt: customSalt }).toString();

                        Y.Assert.areEqual(expectedHash, actualHash);
                    }
                }));

                // MD5
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'MD5',

                    testMD5Vectors: function () {
                        var md5 = C.MD5.create({ salt: null });

                        Y.Assert.areEqual('d41d8cd98f00b204e9800998ecf8427e', md5.compute(''));
                        Y.Assert.areEqual('0cc175b9c0f1b6a831c399e269772661', md5.compute('a'));
                        Y.Assert.areEqual('900150983cd24fb0d6963f7d28e17f72', md5.compute('abc'));
                        Y.Assert.areEqual('f96b697d7cb7938d525a2f31aaf161d0', md5.compute('message digest'));
                        Y.Assert.areEqual('c3fcd3d76192e4007dfb496cca67e13b', md5.compute('abcdefghijklmnopqrstuvwxyz'));
                        Y.Assert.areEqual('d174ab98d277d9f5a5611c2c9f419d9f', md5.compute('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'));
                        Y.Assert.areEqual('57edf4a22be3c955ac49da2e2107b67a', md5.compute('12345678901234567890123456789012345678901234567890123456789012345678901234567890'));
                    },

                    testMD5LongString: function () {
                        var md5 = C.MD5.create({ salt: null });
                        for (var i = 0; i < 100; i++) {
                            md5.update('12345678901234567890123456789012345678901234567890');
                        }
                        var hash = md5.compute();

                        Y.Assert.areEqual('7d017545e0268a6a12f2b507871d0429', hash);
                    }
                }));

                // SHA1
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'SHA1',

                    testSHA1Vectors: function () {
                        var sha1 = C.SHA1.create({ salt: null });

                        Y.Assert.areEqual('da39a3ee5e6b4b0d3255bfef95601890afd80709', sha1.compute(''));
                        Y.Assert.areEqual('86f7e437faa5a7fce15d1ddcb9eaeaea377667b8', sha1.compute('a'));
                        Y.Assert.areEqual('a9993e364706816aba3e25717850c26c9cd0d89d', sha1.compute('abc'));
                        Y.Assert.areEqual('c12252ceda8be8994d5fa0290a47231c1d16aae3', sha1.compute('message digest'));
                        Y.Assert.areEqual('32d10c7b8cf96570ca04ce37f2a19d84240d3a89', sha1.compute('abcdefghijklmnopqrstuvwxyz'));
                        Y.Assert.areEqual('761c457bf73b14d27e9e9265c46f4b4dda11f940', sha1.compute('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'));
                        Y.Assert.areEqual('50abf5706a150990a08b2c5ea40fa0e585554732', sha1.compute('12345678901234567890123456789012345678901234567890123456789012345678901234567890'));
                    },

                    testSHA1LongString: function () {
                        var sha1 = C.SHA1.create({ salt: null });
                        for (var i = 0; i < 100; i++) {
                            sha1.update('12345678901234567890123456789012345678901234567890');
                        }
                        var hash = sha1.compute();

                        Y.Assert.areEqual('85e4c4b3933d5553ebf82090409a9d90226d845c', hash);
                    }
                }));

                // SHA256
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'SHA256',

                    testSHA256Vectors: function () {
                        var sha256 = C.SHA256.create({ salt: null });

                        Y.Assert.areEqual('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', sha256.compute(''));
                        Y.Assert.areEqual('ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb', sha256.compute('a'));
                        Y.Assert.areEqual('ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad', sha256.compute('abc'));
                        Y.Assert.areEqual('f7846f55cf23e14eebeab5b4e1550cad5b509e3348fbc4efa3a1413d393cb650', sha256.compute('message digest'));
                        Y.Assert.areEqual('71c480df93d6ae2f1efad1447c66c9525e316218cf51fc8d9ed832f2daf18b73', sha256.compute('abcdefghijklmnopqrstuvwxyz'));
                        Y.Assert.areEqual('db4bfcbd4da0cd85a60c3c37d3fbd8805c77f15fc6b1fdfe614ee0a7c8fdb4c0', sha256.compute('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'));
                        Y.Assert.areEqual('f371bc4a311f2b009eef952dd83ca80e2b60026c8e935592d0f9c308453c813e', sha256.compute('12345678901234567890123456789012345678901234567890123456789012345678901234567890'));
                    },

                    testSHA256LongString: function () {
                        var sha256 = C.SHA256.create({ salt: null });
                        for (var i = 0; i < 100; i++) {
                            sha256.update('12345678901234567890123456789012345678901234567890');
                        }
                        var hash = sha256.compute();

                        Y.Assert.areEqual('f8146961d9b73d8da49ccd526fca65439cdd5b402f76971556d5f52fd129843e', hash);
                    }
                }));

                // HMAC
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'HMAC',

                    testHMACVectors: function () {
                        Y.Assert.areEqual('9294727a3638bb1c13f48ef8158bfc9d', C.HMAC.compute(C.MD5, 'Hi There', '\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b'));
                        Y.Assert.areEqual('750c783e6ab0b503eaa86e310a5db738', C.HMAC.compute(C.MD5, 'what do ya want for nothing?', 'Jefe'));
                        Y.Assert.areEqual('56be34521d144c88dbb8c733f0e8b3f6', C.HMAC.compute(C.MD5, C.enc.Latin1.decode('\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD'), C.enc.Latin1.decode('\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA')));
                    },

                    testHMACUpdate: function () {
                        var hmac = C.HMAC.create(C.MD5, C.enc.Latin1.decode('\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa'));
                        hmac.update(C.enc.Latin1.decode('\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd'));
                        hmac.update(C.enc.Latin1.decode('\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd'));
                        var hash = hmac.compute(C.enc.Latin1.decode('\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd'));

                        Y.Assert.areEqual('56be34521d144c88dbb8c733f0e8b3f6', hash);
                    }
                }));

                // PBKDF2
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'PBKDF2',

                    testPBKDF2Vectors: function () {
                        Y.Assert.areEqual('cdedb5281bb2f801565a1122b2563515', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 128/32 }));
                        Y.Assert.areEqual('cdedb5281bb2f801565a1122b2563515', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn'));
                        Y.Assert.areEqual('cdedb5281bb2f801565a1122b25635150ad1f7a04bb9f3a333ecc0e2e1f70837', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 256/32 }));
                        Y.Assert.areEqual('01dbee7f4a9e243e988b62c73cda935d', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 128/32, iterations: 2 }));
                        Y.Assert.areEqual('01dbee7f4a9e243e988b62c73cda935da05378b93244ec8f48a99e61ad799d86', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 256/32, iterations: 2 }));
                        Y.Assert.areEqual('5c08eb61fdf71e4e4ec3cf6ba1f5512b', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 128/32, iterations: 1200 }));
                        Y.Assert.areEqual('5c08eb61fdf71e4e4ec3cf6ba1f5512ba7e52ddbc5e5142f708a31e2e62b1e13', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 256/32, iterations: 1200 }));
                        Y.Assert.areEqual('d1daa78615f287e6a1c8b120d7062a49', C.PBKDF2.compute('password', C.enc.Latin1.decode('\x12\x34\x56\x78\x78\x56\x34\x12'), { keySize: 128/32, iterations: 5 }));
                        Y.Assert.areEqual('d1daa78615f287e6a1c8b120d7062a493f98d203e6be49a6adf4fa574b6e64ee', C.PBKDF2.compute('password', C.enc.Latin1.decode('\x12\x34\x56\x78\x78\x56\x34\x12'), { keySize: 256/32, iterations: 5 }));
                        Y.Assert.areEqual('139c30c0966bc32ba55fdbf212530ac9', C.PBKDF2.compute('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX', 'pass phrase equals block size', { keySize: 128/32, iterations: 1200 }));
                        Y.Assert.areEqual('139c30c0966bc32ba55fdbf212530ac9c5ec59f1a452f5cc9ad940fea0598ed1', C.PBKDF2.compute('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX', 'pass phrase equals block size', { keySize: 256/32, iterations: 1200 }));
                        Y.Assert.areEqual('9ccad6d468770cd51b10e6a68721be61', C.PBKDF2.compute('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX', 'pass phrase exceeds block size', { keySize: 128/32, iterations: 1200 }));
                        Y.Assert.areEqual('9ccad6d468770cd51b10e6a68721be611a8b4d282601db3b36be9246915ec82a', C.PBKDF2.compute('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX', 'pass phrase exceeds block size', { keySize: 256/32, iterations: 1200 }));
                        Y.Assert.areEqual('6b9cf26d45455a43a5b8bb276a403b39', C.PBKDF2.compute(C.enc.Latin1.decode('\xf0\x9d\x84\x9e'), 'EXAMPLE.COMpianist', { keySize: 128/32, iterations: 50 }));
                        Y.Assert.areEqual('6b9cf26d45455a43a5b8bb276a403b39e7fe37a0c41e02c281ff3069e1e94f52', C.PBKDF2.compute(C.enc.Latin1.decode('\xf0\x9d\x84\x9e'), 'EXAMPLE.COMpianist', { keySize: 256/32, iterations: 50 }));
                    }
                }));

                // EVP key derivation
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'EvpKeyDerivation',

                    testEvpKeyDerivationVectors: function () {
                        Y.Assert.areEqual('fdbdf3419fff98bdb0241390f62a9db35f4aba29d77566377997314ebfc709f20b5ca7b1081f94b1ac12e3c8ba87d05a', C.EvpKeyDerivation.compute('password', 'saltsalt', { keySize: (256+128)/32 }));
                        // There are no official test vectors that I could find, and the EVP
                        // implementation is short on comments. Someone should use the C code to
                        // generate more test vectors. The iteration count in particular needs to be
                        // tested.
                    }
                }));

                // RC4
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'RC4',

                    testRC4Vectors: function () {
                        Y.Assert.areEqual(
                            '7494c2e7104b0879',
                            C.ARC4.encrypt(
                                C.lib.WordArray.create([0x00000000, 0x00000000]), // message
                                C.lib.WordArray.create([0x01234567, 0x89abcdef])  // key
                            ).rawData.toString(C.enc.Hex)
                        );

                        Y.Assert.areEqual(
                            'f13829c9de',
                            C.ARC4.encrypt(
                                C.lib.WordArray.create([0xdcee4cf9, 0x2c000000], 5), // message
                                C.lib.WordArray.create([0x618a63d2, 0xfb000000], 5)  // key
                            ).rawData.toString(C.enc.Hex)
                        );
                    }
                }));

                // Test runner
                Y.Test.Runner.add(cryptoJsTestSuite);

                new Y.Console({
                    style: 'block',
                    width: '600px',
                    height: '600px',
                    entryTemplate:
                      '<div class="{entry_class} {cat_class} {src_class}">' +
                      '    <p class="{entry_meta_class}">' +
                      '        <span class="{entry_cat_class}">{category}</span>' +
                      '    </p>' +
                      '    <pre class="{entry_content_class}">{message}</pre>' +
                      '</div>',
                    newestOnTop: false,
                    render: true
                });

                Y.Test.Runner.run();
            });
        </script>

        <style type="text/css">
            body.yui3-skin-sam .yui3-console-entry-meta,
            body.yui3-skin-sam .yui3-console-entry-content {
                display: inline-block;
                vertical-align: top;
            }
            body.yui3-skin-sam .yui3-console-entry-cat {
                display: inline-block;
                width: 35px;
                text-align: center;
            }
            body.yui3-skin-sam .yui3-console-entry {
                min-height: 0;
            }
        </style>
    </head>
    <body class="yui3-skin-sam">
    </body>
</html>
