<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>CryptoJS Test Suite</title>

        <!-- CryptoJS -->
        <script src="../src/core.js"></script>
        <script src="../src/base64.js"></script>
        <script src="../src/md5.js"></script>
        <script src="../src/sha1.js"></script>
        <script src="../src/sha256.js"></script>
        <script src="../src/modcrypt.js"></script>
        <script src="../src/hmac.js"></script>
        <script src="../src/pbkdf2.js"></script>
        <script src="../src/evp-key-derivation.js"></script>
        <script src="../src/cipher_base.js"></script>
        <script src="../src/rc4.js"></script>

        <!-- YUI -->
        <script src="http://yui.yahooapis.com/3.3.0/build/yui/yui-min.js"></script>

        <!-- Tests -->
        <script type="text/javascript">
            YUI().use('test', 'console', function (Y) {
                // Shortcut
                var C = CryptoJS;

                // Augment WordArray with "stringify" for testing
                C.lib.WordArray.stringify = function (options) {
                    if (options && options.clamp) {
                        this.clamp();
                    }

                    var formattedWords = [];
                    for (var i = 0; i < this.words.length; i++) {
                        formattedWords[i] = '0x' + (this.words[i] >>> 0).toString(16);
                    }

                    return '{words:[' + formattedWords.join(',') + '],sigBytes:' + this.sigBytes + '}';
                };

                // CryptoJS test suite
                var cryptoJsTestSuite = new Y.Test.Suite('CryptoJS');

                // Base lib
                var libBaseTestSuite = new Y.Test.Suite('lib.Base');
                cryptoJsTestSuite.add(libBaseTestSuite);

                // extend
                libBaseTestSuite.add(new Y.Test.Case({
                    name: 'extend',

                    setUp: function () {
                        this.data = {};

                        this.data.overrides = {
                            abc: 'abc',
                            toString: function () {}
                        };

                        this.data.obj = C.lib.Base.extend(this.data.overrides);
                    },

                    testInheritance: function () {
                        Y.Assert.areEqual(C.lib.Base.extend, this.data.obj.extend);
                        Y.Assert.isFalse(this.data.obj.hasOwnProperty('extend'));
                    },

                    testSuper: function () {
                        Y.Assert.areEqual(C.lib.Base, this.data.obj.$super);
                    },

                    testOverrides: function () {
                        // abc
                        Y.Assert.areEqual(this.data.overrides.abc, this.data.obj.abc);
                        Y.Assert.isTrue(this.data.obj.hasOwnProperty('abc'));

                        // toString
                        Y.Assert.areEqual(this.data.overrides.toString, this.data.obj.toString);
                        Y.Assert.isTrue(this.data.obj.hasOwnProperty('toString'));
                    }
                }));

                // create
                libBaseTestSuite.add(new Y.Test.Case({
                    name: 'create',

                    setUp: function () {
                        this.data = {};

                        this.data.Obj = C.lib.Base.extend({
                            init: function (arg) {
                                this.initFired = true;
                                this.arg = arg;
                            }
                        });

                        this.data.obj = this.data.Obj.create('arg');
                    },

                    testInheritance: function () {
                        // from Obj
                        Y.Assert.areEqual(this.data.Obj.init, this.data.obj.init);
                        Y.Assert.isFalse(this.data.obj.hasOwnProperty('init'));

                        // from Base
                        Y.Assert.areEqual(C.lib.Base.extend, this.data.obj.extend);
                        Y.Assert.isFalse(this.data.obj.hasOwnProperty('extend'));
                    },

                    testSuper: function () {
                        Y.Assert.areEqual(this.data.Obj, this.data.obj.$super);
                    },

                    testInit: function () {
                        Y.Assert.isTrue(this.data.obj.initFired);
                        Y.Assert.areEqual('arg', this.data.obj.arg);
                    }
                }));

                // clone
                libBaseTestSuite.add(new Y.Test.Case({
                    name: 'clone',

                    setUp: function () {
                        this.data = {};

                        this.data.obj = C.lib.Base.extend({
                            abc: 'abc'
                        });

                        this.data.objClone = this.data.obj.clone();
                    },

                    testDistinct: function () {
                        Y.Assert.areNotEqual(this.data.obj, this.data.objClone);
                    },

                    testCopy: function () {
                        Y.Assert.areEqual(this.data.obj.abc, this.data.objClone.abc);
                    },

                    testIndependent: function () {
                        this.data.obj.abc = 'xyz';

                        Y.Assert.areNotEqual(this.data.obj.abc, this.data.objClone.abc);
                    }
                }));

                // cast
                libBaseTestSuite.add(new Y.Test.Case({
                    name: 'cast',

                    setUp: function () {
                        this.data = {};

                        this.data.Obj1 = C.lib.Base.extend();
                        this.data.Obj2 = C.lib.Base.extend();

                        this.data.obj = this.data.Obj1.create();
                        this.data.obj.abc = 'abc';

                        this.data.objCasted = this.data.Obj2.cast(this.data.obj);
                    },

                    testCopy: function () {
                        Y.Assert.areEqual(this.data.obj.abc, this.data.objCasted.abc);
                    },

                    testSuper: function () {
                        Y.Assert.areEqual(this.data.Obj2, this.data.objCasted.$super);
                    }
                }));

                // isA
                libBaseTestSuite.add(new Y.Test.Case({
                    name: 'isA',

                    setUp: function () {
                        this.data = {};

                        this.data.Obj1 = C.lib.Base.extend();
                        this.data.Obj2 = C.lib.Base.extend();

                        this.data.obj1 = this.data.Obj1.create();
                        this.data.obj2 = this.data.Obj2.create();
                    },

                    testIsA: function () {
                        Y.Assert.isTrue(this.data.obj1.isA(this.data.Obj1));
                        Y.Assert.isTrue(this.data.obj1.isA(C.lib.Base));

                        Y.Assert.isTrue(this.data.obj2.isA(this.data.Obj2));
                        Y.Assert.isTrue(this.data.obj2.isA(C.lib.Base));
                    },

                    testNotIsA: function () {
                        Y.Assert.isFalse( !! this.data.obj2.isA(this.data.Obj1));
                        Y.Assert.isFalse( !! this.data.obj1.isA(this.data.Obj2));
                    }
                }));

                // WordArray lib
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'lib.WordArray',

                    testInit0: function () {
                        var wordArray = C.lib.WordArray.create();

                        Y.Assert.areEqual('{words:[],sigBytes:0}', wordArray.stringify());
                    },

                    testInit1: function () {
                        var wordArray = C.lib.WordArray.create([0x12345678]);

                        Y.Assert.areEqual('{words:[0x12345678],sigBytes:4}', wordArray.stringify());
                    },

                    testInit2: function () {
                        var wordArray = C.lib.WordArray.create([0x12345678], 2);

                        Y.Assert.areEqual('{words:[0x12345678],sigBytes:2}', wordArray.stringify());
                    },

                    testToString: function () {
                        Y.Assert.areEqual('48656c6c6f2c20576f726c6421', C.enc.Base64.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13).toString(C.enc.Hex));
                        Y.Assert.areEqual('Hello, World!', C.enc.Hex.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13).toString(C.enc.Latin1));
                        Y.Assert.areEqual('¢', C.enc.Latin1.create([0xc2a20000], 2).toString(C.enc.Utf8));
                        Y.Assert.areEqual('Zm8=', C.enc.Utf8.create([0x666f6f62, 0x61720000], 2).toString(C.enc.Base64));

                        Y.Assert.areEqual('48656c6c6f2c20576f726c6421', C.enc.Hex.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13).toString());
                        Y.Assert.areEqual('Hello, World!', C.enc.Latin1.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13).toString());
                        Y.Assert.areEqual('¢', C.enc.Utf8.create([0xc2a20000], 2).toString());
                        Y.Assert.areEqual('Zm8=', C.enc.Base64.create([0x666f6f62, 0x61720000], 2).toString());
                    },

                    testConcat: function () {
                        Y.Assert.areEqual(
                            // Expected
                            '{words:[0x61626361,0x62630000],sigBytes:6}',
                            // Actual
                            C.lib.WordArray.create([0x61626300], 3).concat(
                                C.lib.WordArray.create([0x61626300], 3)
                            ).stringify()
                        );
                    },

                    testClamp: function () {
                        var wordArray = C.lib.WordArray.create([0x61626361, 0x62630000], 3);
                        wordArray.clamp();

                        Y.Assert.areEqual('{words:[0x61626300],sigBytes:3}', wordArray.stringify());
                    },

                    testRandom: function () {
                        Y.Assert.areNotEqual(C.lib.WordArray.random(8).stringify(), C.lib.WordArray.random(8).stringify());
                        Y.Assert.areEqual(8, C.lib.WordArray.random(8).sigBytes);
                    }
                }));

                // Hex encoder
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'enc.Hex',

                    testToString: function () {
                        Y.Assert.areEqual(
                            // Expected
                            '48656c6c6f2c20576f726c6421',
                            // Actual
                            C.enc.Hex.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13).toString()
                        );
                    },

                    testFromString: function () {
                        Y.Assert.areEqual(
                            // Expected
                            '{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}',
                            // Actual
                            C.enc.Hex.fromString('48656c6c6f2c20576f726c6421').stringify()
                        );
                    }
                }));

                // Latin1 encoder
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'enc.Latin1',

                    testToString: function () {
                        Y.Assert.areEqual(
                            // Expected
                            'Hello, World!',
                            // Actual
                            C.enc.Latin1.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13).toString()
                        );
                    },

                    testFromString: function () {
                        Y.Assert.areEqual(
                            // Expected
                            '{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}',
                            // Actual
                            C.enc.Latin1.fromString('Hello, World!').stringify()
                        );
                    }
                }));

                // Utf8 encoder
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'enc.Utf8',

                    testToString: function () {
                        Y.Assert.areEqual('$', C.enc.Utf8.create([0x24000000], 1).toString());
                        Y.Assert.areEqual('¢', C.enc.Utf8.create([0xc2a20000], 2).toString());
                        Y.Assert.areEqual('€', C.enc.Utf8.create([0xe282ac00], 3).toString());
                        Y.Assert.areEqual('𤭢', C.enc.Utf8.create([0xf0a4ada2], 4).toString());
                    },

                    testFromString: function () {
                        Y.Assert.areEqual('{words:[0x24000000],sigBytes:1}', C.enc.Utf8.fromString('$').stringify());
                        Y.Assert.areEqual('{words:[0xc2a20000],sigBytes:2}', C.enc.Utf8.fromString('¢').stringify());
                        Y.Assert.areEqual('{words:[0xe282ac00],sigBytes:3}', C.enc.Utf8.fromString('€').stringify());
                        Y.Assert.areEqual('{words:[0xf0a4ada2],sigBytes:4}', C.enc.Utf8.fromString('𤭢').stringify());
                    }
                }));

                // Base64 encoder
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'enc.Base64',

                    testToString: function () {
                        Y.Assert.areEqual('', C.enc.Base64.create([0x666f6f62, 0x61720000], 0).toString());
                        Y.Assert.areEqual('Zg==', C.enc.Base64.create([0x666f6f62, 0x61720000], 1).toString());
                        Y.Assert.areEqual('Zm8=', C.enc.Base64.create([0x666f6f62, 0x61720000], 2).toString());
                        Y.Assert.areEqual('Zm9v', C.enc.Base64.create([0x666f6f62, 0x61720000], 3).toString());
                        Y.Assert.areEqual('Zm9vYg==', C.enc.Base64.create([0x666f6f62, 0x61720000], 4).toString());
                        Y.Assert.areEqual('Zm9vYmE=', C.enc.Base64.create([0x666f6f62, 0x61720000], 5).toString());
                        Y.Assert.areEqual('Zm9vYmFy', C.enc.Base64.create([0x666f6f62, 0x61720000], 6).toString());
                        Y.Assert.areEqual('Pj4+Pz8/Pj4+Pz8/PS8r', C.enc.Base64.create([0x3e3e3e3f, 0x3f3f3e3e, 0x3e3f3f3f, 0x3d2f2b00], 15).toString());
                    },

                    testFromString: function () {
                        Y.Assert.areEqual('{words:[],sigBytes:0}', C.enc.Base64.fromString('').stringify());
                        Y.Assert.areEqual('{words:[0x66000000],sigBytes:1}', C.enc.Base64.fromString('Zg==').stringify());
                        Y.Assert.areEqual('{words:[0x666f0000],sigBytes:2}', C.enc.Base64.fromString('Zm8=').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f00],sigBytes:3}', C.enc.Base64.fromString('Zm9v').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f62],sigBytes:4}', C.enc.Base64.fromString('Zm9vYg==').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f62,0x61000000],sigBytes:5}', C.enc.Base64.fromString('Zm9vYmE=').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f62,0x61720000],sigBytes:6}', C.enc.Base64.fromString('Zm9vYmFy').stringify());
                        Y.Assert.areEqual('{words:[0x3e3e3e3f,0x3f3f3e3e,0x3e3f3f3f,0x3d2f2b00],sigBytes:15}', C.enc.Base64.fromString('Pj4+Pz8/Pj4+Pz8/PS8r').stringify());
                    }
                }));

                // Event lib
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'lib.Event',

                    testSubscribeFire: function () {
                        // Callback
                        var callbackFired = false;
                        function callback() {
                            callbackFired = true;
                        }

                        // Subscribe
                        var event = C.lib.Event.create();
                        event.subscribe(callback);

                        // Fire
                        event.fire();

                        // Test fired
                        Y.Assert.isTrue(callbackFired);
                    }
                }));

                // OpenSSL hash formatter
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'hash.formatter.OpenSSL',

                    testToString: function () {
                        var rawData = C.enc.Hex.create([0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210]);
                        var salt = C.enc.Hex.create([0xfedcba98, 0x76543210]);
                        var formatter = C.hash.formatter.OpenSSL.create(rawData, salt);

                        Y.Assert.areEqual('53616c7465645f5ffedcba98765432100123456789abcdeffedcba9876543210', formatter.toString());
                        Y.Assert.areEqual('U2FsdGVkX1/+3LqYdlQyEAEjRWeJq83v/ty6mHZUMhA=', formatter.toString(C.enc.Base64));
                    },

                    testFromString: function () {
                        var saltedHash   = C.hash.formatter.OpenSSL.fromString('53616c7465645f5f0123456789abcdef0123456789abcdef0123456789abcdef');
                        var unsaltedHash = C.hash.formatter.OpenSSL.fromString('0123456789abcdef0123456789abcdef');

                        Y.Assert.areEqual('{words:[0x1234567,0x89abcdef,0x1234567,0x89abcdef],sigBytes:16}', saltedHash.rawData.stringify());
                        Y.Assert.areEqual('{words:[0x1234567,0x89abcdef],sigBytes:8}', saltedHash.salt.stringify());

                        Y.Assert.areEqual('{words:[0x1234567,0x89abcdef,0x1234567,0x89abcdef],sigBytes:16}', unsaltedHash.rawData.stringify());
                        Y.Assert.isUndefined(unsaltedHash.salt);
                    }
                }));

                // Base hash
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'hash.Base',

                    testUpdate: function () {
                        var expectedHash = C.MD5.compute('12345678901234567890123456789012345678901234567890123456789012345678901234567890', { salt: null }).toString();

                        var md5 = C.MD5.create({ salt: null });
                        md5.update('1234567890123456789012345678901234567890');
                        md5.update('12345678901234567890');
                        var actualHash = md5.compute('12345678901234567890').toString();

                        Y.Assert.areEqual(expectedHash, actualHash);
                    },

                    testInputStable: function () {
                        var message = C.enc.Latin1.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13);
                        var hash = C.MD5.compute(message);

                        Y.Assert.areEqual('{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}', message.stringify());
                    },

                    testCustomSalt: function () {
                        var salt = C.enc.Hex.create([0x01234567, 0x89abcdef]);

                        var rawHash = C.MD5.create({ salt: null }).update(salt).compute('abc').rawData;
                        var expectedHash = C.enc.Latin1.fromString('Salted__').concat(salt).concat(rawHash).toString(C.enc.Hex);

                        var actualHash = C.MD5.compute('abc', { salt: salt }).toString();

                        Y.Assert.areEqual(actualHash, expectedHash);
                    },

                    testRandomSalt: function () {
                        Y.Assert.areNotEqual(
                            C.MD5.compute().salt.stringify(),
                            C.MD5.compute().salt.stringify()
                        );
                    },

                    testBeforeComputeSalter: function () {
                        var salt = C.enc.Hex.create([0x01234567, 0x89abcdef]);

                        var beforeComputeSalter = {
                            execute: function (hasher) {
                                // Shortcut
                                var cfg = hasher.cfg;

                                if (cfg.salt) {
                                    hasher.beforeCompute.subscribe(function () {
                                        hasher.update(cfg.salt);
                                    });
                                }
                            }
                        };

                        var rawHash = C.MD5.create({ salt: null }).update('abc').compute(salt).rawData;
                        var expectedHash = C.enc.Latin1.fromString('Salted__').concat(salt).concat(rawHash).toString(C.enc.Hex);

                        var actualHash = C.MD5.compute('abc', { salt: salt, salter: beforeComputeSalter }).toString();

                        Y.Assert.areEqual(expectedHash, actualHash);
                    },

                    testAfterComputeSalter: function () {
                        var salt = C.enc.Hex.create([0x01234567, 0x89abcdef]);

                        var afterComputeSalter = {
                            execute: function (hasher) {
                                // Shortcut
                                var cfg = hasher.cfg;

                                // Salt
                                if (cfg.salt) {
                                    hasher.afterCompute.subscribe(function () {
                                        var newHasher = hasher.$super.create({ salt: null });
                                        hasher.hash = newHasher.update(cfg.salt).compute(hasher.hash).rawData;
                                    });
                                }
                            }
                        };

                        var md5 = C.MD5.create({ salt: null });
                        var intermediate = md5.compute('abc').rawData;
                        var rawHash = md5.update(salt).compute(intermediate).rawData
                        var expectedHash = C.enc.Latin1.fromString('Salted__').concat(salt).concat(rawHash).toString(C.enc.Hex);

                        var actualHash = C.MD5.compute('abc', { salt: salt, salter: afterComputeSalter }).toString();

                        Y.Assert.areEqual(expectedHash, actualHash);
                    },

                    testCustomFormatter: function () {
                        var salt = C.enc.Hex.create([0x01234567, 0x89abcdef]);

                        var formatter = C.lib.Formatter.extend({
                            toString: function () {
                                var hashStr = '{ hash: "' + this.rawData.toString(C.enc.Hex) + '"';
                                if (this.salt) {
                                    hashStr += ', salt: "' + this.salt.toString(C.enc.Hex) + '"';
                                }
                                hashStr += ' }';

                                return hashStr;
                            }
                        });

                        var hash = C.MD5.compute('abc', { salt: salt });
                        var expectedHash = '{ hash: "' + hash.rawData.toString(C.enc.Hex) + '", salt: "' + hash.salt.toString(C.enc.Hex) + '" }';

                        var actualHash = C.MD5.compute('abc', { formatter: formatter, salt: salt }).toString();

                        Y.Assert.areEqual(expectedHash, actualHash);
                    }
                }));

                // MD5
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'MD5',

                    testVectors: function () {
                        var md5 = C.MD5.create({ salt: null });

                        Y.Assert.areEqual('d41d8cd98f00b204e9800998ecf8427e', md5.compute(''));
                        Y.Assert.areEqual('0cc175b9c0f1b6a831c399e269772661', md5.compute('a'));
                        Y.Assert.areEqual('900150983cd24fb0d6963f7d28e17f72', md5.compute('abc'));
                        Y.Assert.areEqual('f96b697d7cb7938d525a2f31aaf161d0', md5.compute('message digest'));
                        Y.Assert.areEqual('c3fcd3d76192e4007dfb496cca67e13b', md5.compute('abcdefghijklmnopqrstuvwxyz'));
                        Y.Assert.areEqual('d174ab98d277d9f5a5611c2c9f419d9f', md5.compute('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'));
                        Y.Assert.areEqual('57edf4a22be3c955ac49da2e2107b67a', md5.compute('12345678901234567890123456789012345678901234567890123456789012345678901234567890'));
                    },

                    testLongString: function () {
                        var md5 = C.MD5.create({ salt: null });
                        for (var i = 0; i < 100; i++) {
                            md5.update('12345678901234567890123456789012345678901234567890');
                        }
                        var hash = md5.compute();

                        Y.Assert.areEqual('7d017545e0268a6a12f2b507871d0429', hash);
                    }
                }));

                // SHA1
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'SHA1',

                    testVectors: function () {
                        var sha1 = C.SHA1.create({ salt: null });

                        Y.Assert.areEqual('da39a3ee5e6b4b0d3255bfef95601890afd80709', sha1.compute(''));
                        Y.Assert.areEqual('86f7e437faa5a7fce15d1ddcb9eaeaea377667b8', sha1.compute('a'));
                        Y.Assert.areEqual('a9993e364706816aba3e25717850c26c9cd0d89d', sha1.compute('abc'));
                        Y.Assert.areEqual('c12252ceda8be8994d5fa0290a47231c1d16aae3', sha1.compute('message digest'));
                        Y.Assert.areEqual('32d10c7b8cf96570ca04ce37f2a19d84240d3a89', sha1.compute('abcdefghijklmnopqrstuvwxyz'));
                        Y.Assert.areEqual('761c457bf73b14d27e9e9265c46f4b4dda11f940', sha1.compute('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'));
                        Y.Assert.areEqual('50abf5706a150990a08b2c5ea40fa0e585554732', sha1.compute('12345678901234567890123456789012345678901234567890123456789012345678901234567890'));
                    },

                    testLongString: function () {
                        var sha1 = C.SHA1.create({ salt: null });
                        for (var i = 0; i < 100; i++) {
                            sha1.update('12345678901234567890123456789012345678901234567890');
                        }
                        var hash = sha1.compute();

                        Y.Assert.areEqual('85e4c4b3933d5553ebf82090409a9d90226d845c', hash);
                    }
                }));

                // SHA256
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'SHA256',

                    testVectors: function () {
                        var sha256 = C.SHA256.create({ salt: null });

                        Y.Assert.areEqual('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', sha256.compute(''));
                        Y.Assert.areEqual('ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb', sha256.compute('a'));
                        Y.Assert.areEqual('ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad', sha256.compute('abc'));
                        Y.Assert.areEqual('f7846f55cf23e14eebeab5b4e1550cad5b509e3348fbc4efa3a1413d393cb650', sha256.compute('message digest'));
                        Y.Assert.areEqual('71c480df93d6ae2f1efad1447c66c9525e316218cf51fc8d9ed832f2daf18b73', sha256.compute('abcdefghijklmnopqrstuvwxyz'));
                        Y.Assert.areEqual('db4bfcbd4da0cd85a60c3c37d3fbd8805c77f15fc6b1fdfe614ee0a7c8fdb4c0', sha256.compute('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'));
                        Y.Assert.areEqual('f371bc4a311f2b009eef952dd83ca80e2b60026c8e935592d0f9c308453c813e', sha256.compute('12345678901234567890123456789012345678901234567890123456789012345678901234567890'));
                    },

                    testLongString: function () {
                        var sha256 = C.SHA256.create({ salt: null });
                        for (var i = 0; i < 100; i++) {
                            sha256.update('12345678901234567890123456789012345678901234567890');
                        }
                        var hash = sha256.compute();

                        Y.Assert.areEqual('f8146961d9b73d8da49ccd526fca65439cdd5b402f76971556d5f52fd129843e', hash);
                    }
                }));

                // Crypt encoder
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'enc.Crypt',

                    testToString: function () {
                        Y.Assert.areEqual('', C.enc.Crypt.create([0x666f6f62, 0x61720000], 0).toString());
                        Y.Assert.areEqual('NU', C.enc.Crypt.create([0x666f6f62, 0x61720000], 1).toString());
                        Y.Assert.areEqual('Naw', C.enc.Crypt.create([0x666f6f62, 0x61720000], 2).toString());
                        Y.Assert.areEqual('Naxj', C.enc.Crypt.create([0x666f6f62, 0x61720000], 3).toString());
                        Y.Assert.areEqual('NaxjMU', C.enc.Crypt.create([0x666f6f62, 0x61720000], 4).toString());
                        Y.Assert.areEqual('NaxjMa2', C.enc.Crypt.create([0x666f6f62, 0x61720000], 5).toString());
                        Y.Assert.areEqual('NaxjMa3m', C.enc.Crypt.create([0x666f6f62, 0x61720000], 6).toString());
                        Y.Assert.areEqual('DXsyDnwzDXsyDnwzDGwf', C.enc.Crypt.create([0x3e3e3e3f, 0x3f3f3e3e, 0x3e3f3f3f, 0x3d2f2b00], 15).toString());
                    },

                    testFromString: function () {
                        Y.Assert.areEqual('{words:[],sigBytes:0}', C.enc.Crypt.fromString('').stringify());
                        Y.Assert.areEqual('{words:[0x66000000],sigBytes:1}', C.enc.Crypt.fromString('NU').stringify());
                        Y.Assert.areEqual('{words:[0x666f0000],sigBytes:2}', C.enc.Crypt.fromString('Naw').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f00],sigBytes:3}', C.enc.Crypt.fromString('Naxj').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f62],sigBytes:4}', C.enc.Crypt.fromString('NaxjMU').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f62,0x61000000],sigBytes:5}', C.enc.Crypt.fromString('NaxjMa2').stringify());
                        Y.Assert.areEqual('{words:[0x666f6f62,0x61720000],sigBytes:6}', C.enc.Crypt.fromString('NaxjMa3m').stringify());
                        Y.Assert.areEqual('{words:[0x3e3e3e3f,0x3f3f3e3e,0x3e3f3f3f,0x3d2f2b00],sigBytes:15}', C.enc.Crypt.fromString('DXsyDnwzDXsyDnwzDGwf').stringify());
                    }
                }));

                // ModCrypt hash salter
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'hash.salter.ModCrypt',

                    testSomething: function () {
                        // Need to make test cases
                        Y.Assert.fail();
                    }
                }));

                // ModCrypt hash formatter
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'hash.formatter.ModCrypt',

                    testToString: function () {
                        var rawData = C.enc.Hex.create([0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210]);
                        var salt = C.enc.Hex.create([0xfedcba98, 0x76543210]);
                        var formatter = C.hash.formatter.ModCrypt.create(rawData, salt);

                        formatter.hasher = C.MD5;
                        Y.Assert.areEqual('$1$zhmua5NIAV.$.GB3NsafnSzyr9eMRZEm2.', formatter.toString());

                        formatter.hasher = C.SHA1;
                        Y.Assert.areEqual('$sha1$zhmua5NIAV.$.GB3NsafnSzyr9eMRZEm2.', formatter.toString());

                        formatter.hasher = C.SHA256;
                        Y.Assert.areEqual('$5$zhmua5NIAV.$.GB3NsafnSzyr9eMRZEm2.', formatter.toString());
                    },

                    testFromString: function () {
                        var hash = C.hash.formatter.ModCrypt.fromString('$1$zhmua5NIAV.$.GB3NsafnSzyr9eMRZEm2.');
                        Y.Assert.areEqual('{words:[0x1234567,0x89abcdef,0xfedcba98,0x76543210],sigBytes:16}', hash.rawData.stringify());
                        Y.Assert.areEqual('{words:[0xfedcba98,0x76543210],sigBytes:8}', hash.salt.stringify());
                        Y.Assert.areEqual(C.MD5, hash.hasher);

                        var hash = C.hash.formatter.ModCrypt.fromString('$sha1$zhmua5NIAV.$.GB3NsafnSzyr9eMRZEm2.');
                        Y.Assert.areEqual('{words:[0x1234567,0x89abcdef,0xfedcba98,0x76543210],sigBytes:16}', hash.rawData.stringify());
                        Y.Assert.areEqual('{words:[0xfedcba98,0x76543210],sigBytes:8}', hash.salt.stringify());
                        Y.Assert.areEqual(C.SHA1, hash.hasher);

                        var hash = C.hash.formatter.ModCrypt.fromString('$5$zhmua5NIAV.$.GB3NsafnSzyr9eMRZEm2.');
                        Y.Assert.areEqual('{words:[0x1234567,0x89abcdef,0xfedcba98,0x76543210],sigBytes:16}', hash.rawData.stringify());
                        Y.Assert.areEqual('{words:[0xfedcba98,0x76543210],sigBytes:8}', hash.salt.stringify());
                        Y.Assert.areEqual(C.SHA256, hash.hasher);
                    }
                }));

                // ModCrypt
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'ModCrypt',

                    testSomething: function () {
                        // Need to make test cases
                        Y.Assert.fail();
                    }
                }));

                // HMAC
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'HMAC',

                    testVectors: function () {
                        Y.Assert.areEqual('9294727a3638bb1c13f48ef8158bfc9d', C.HMAC.compute(C.MD5, 'Hi There', '\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b'));
                        Y.Assert.areEqual('750c783e6ab0b503eaa86e310a5db738', C.HMAC.compute(C.MD5, 'what do ya want for nothing?', 'Jefe'));
                        Y.Assert.areEqual('56be34521d144c88dbb8c733f0e8b3f6', C.HMAC.compute(C.MD5, C.enc.Latin1.fromString('\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD'), C.enc.Latin1.fromString('\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA')));
                    },

                    testUpdate: function () {
                        var hmac = C.HMAC.create(C.MD5, C.enc.Latin1.fromString('\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa'));
                        hmac.update(C.enc.Latin1.fromString('\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd'));
                        hmac.update(C.enc.Latin1.fromString('\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd'));
                        var hash = hmac.compute(C.enc.Latin1.fromString('\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd'));

                        Y.Assert.areEqual('56be34521d144c88dbb8c733f0e8b3f6', hash);
                    },

                    testInputStable: function () {
                        var message = C.enc.Latin1.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13);
                        var key = C.enc.Latin1.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13);
                        var hmac = C.HMAC.compute(C.MD5, message, key);

                        Y.Assert.areEqual('{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}', message.stringify());
                        Y.Assert.areEqual('{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}', key.stringify());
                    }
                }));

                // PBKDF2
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'PBKDF2',

                    testPBKDF2Vectors: function () {
                        Y.Assert.areEqual('cdedb5281bb2f801565a1122b2563515', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 128/32 }));
                        Y.Assert.areEqual('cdedb5281bb2f801565a1122b2563515', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn'));
                        Y.Assert.areEqual('cdedb5281bb2f801565a1122b25635150ad1f7a04bb9f3a333ecc0e2e1f70837', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 256/32 }));
                        Y.Assert.areEqual('01dbee7f4a9e243e988b62c73cda935d', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 128/32, iterations: 2 }));
                        Y.Assert.areEqual('01dbee7f4a9e243e988b62c73cda935da05378b93244ec8f48a99e61ad799d86', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 256/32, iterations: 2 }));
                        Y.Assert.areEqual('5c08eb61fdf71e4e4ec3cf6ba1f5512b', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 128/32, iterations: 1200 }));
                        Y.Assert.areEqual('5c08eb61fdf71e4e4ec3cf6ba1f5512ba7e52ddbc5e5142f708a31e2e62b1e13', C.PBKDF2.compute('password', 'ATHENA.MIT.EDUraeburn', { keySize: 256/32, iterations: 1200 }));
                        Y.Assert.areEqual('d1daa78615f287e6a1c8b120d7062a49', C.PBKDF2.compute('password', C.enc.Latin1.fromString('\x12\x34\x56\x78\x78\x56\x34\x12'), { keySize: 128/32, iterations: 5 }));
                        Y.Assert.areEqual('d1daa78615f287e6a1c8b120d7062a493f98d203e6be49a6adf4fa574b6e64ee', C.PBKDF2.compute('password', C.enc.Latin1.fromString('\x12\x34\x56\x78\x78\x56\x34\x12'), { keySize: 256/32, iterations: 5 }));
                        Y.Assert.areEqual('139c30c0966bc32ba55fdbf212530ac9', C.PBKDF2.compute('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX', 'pass phrase equals block size', { keySize: 128/32, iterations: 1200 }));
                        Y.Assert.areEqual('139c30c0966bc32ba55fdbf212530ac9c5ec59f1a452f5cc9ad940fea0598ed1', C.PBKDF2.compute('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX', 'pass phrase equals block size', { keySize: 256/32, iterations: 1200 }));
                        Y.Assert.areEqual('9ccad6d468770cd51b10e6a68721be61', C.PBKDF2.compute('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX', 'pass phrase exceeds block size', { keySize: 128/32, iterations: 1200 }));
                        Y.Assert.areEqual('9ccad6d468770cd51b10e6a68721be611a8b4d282601db3b36be9246915ec82a', C.PBKDF2.compute('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX', 'pass phrase exceeds block size', { keySize: 256/32, iterations: 1200 }));
                        Y.Assert.areEqual('6b9cf26d45455a43a5b8bb276a403b39', C.PBKDF2.compute(C.enc.Latin1.fromString('\xf0\x9d\x84\x9e'), 'EXAMPLE.COMpianist', { keySize: 128/32, iterations: 50 }));
                        Y.Assert.areEqual('6b9cf26d45455a43a5b8bb276a403b39e7fe37a0c41e02c281ff3069e1e94f52', C.PBKDF2.compute(C.enc.Latin1.fromString('\xf0\x9d\x84\x9e'), 'EXAMPLE.COMpianist', { keySize: 256/32, iterations: 50 }));
                    },

                    testInputStable: function () {
                        var password = C.enc.Latin1.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13);
                        var salt = C.enc.Latin1.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13);
                        var key = C.PBKDF2.compute(password, salt);

                        Y.Assert.areEqual('{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}', password.stringify());
                        Y.Assert.areEqual('{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}', salt.stringify());
                    }
                }));

                // EVP key derivation
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'EvpKeyDerivation',

                    testVectors: function () {
                        Y.Assert.areEqual(
                            // Expected
                            'fdbdf3419fff98bdb0241390f62a9db35f4aba29d77566377997314ebfc709f20b5ca7b1081f94b1ac12e3c8ba87d05a',
                            // Actual
                            C.EvpKeyDerivation.compute('password', 'saltsalt', { keySize: (256+128)/32 })
                        );

                        // There are no official test vectors that I could find, and the EVP
                        // implementation is short on comments. Someone should use the C code to
                        // generate more test vectors. The iteration count in particular needs to be
                        // tested.
                    },

                    testInputStable: function () {
                        var password = C.enc.Latin1.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13);
                        var salt = C.enc.Latin1.create([0x48656c6c, 0x6f2c2057, 0x6f726c64, 0x21000000], 13);
                        var key = C.EvpKeyDerivation.compute(password, salt);

                        Y.Assert.areEqual('{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}', password.stringify());
                        Y.Assert.areEqual('{words:[0x48656c6c,0x6f2c2057,0x6f726c64,0x21000000],sigBytes:13}', salt.stringify());
                    }
                }));

                // RC4
                cryptoJsTestSuite.add(new Y.Test.Case({
                    name: 'RC4',

                    testEncrypt: function () {
                        Y.Assert.areEqual(
                            // Expected
                            '7494c2e7104b0879',
                            // Actual
                            C.RC4.encrypt(
                                // Message
                                C.lib.WordArray.create([0x00000000, 0x00000000]),
                                // Key
                                C.lib.WordArray.create([0x01234567, 0x89abcdef]),
                                // Config
                                { drop: 0 }
                            ).rawData.toString(C.enc.Hex)
                        );

                        Y.Assert.areEqual(
                            // Expected
                            'f13829c9de',
                            // Actual
                            C.RC4.encrypt(
                                // Message
                                C.lib.WordArray.create([0xdcee4cf9, 0x2c000000], 5),
                                // Key
                                C.lib.WordArray.create([0x618a63d2, 0xfb000000], 5),
                                // Config
                                { drop: 0 }
                            ).rawData.toString(C.enc.Hex)
                        );
                    },

                    testDecrypt: function () {
                        Y.Assert.areEqual(
                            // Expected
                            C.lib.WordArray.create([0x00000000, 0x00000000]).stringify(),
                            // Actual
                            C.RC4.decrypt(
                                // Ciphertext
                                C.cipher.formatter.OpenSSL.create(C.lib.WordArray.create([0x7494c2e7, 0x104b0879])),
                                // Key
                                C.lib.WordArray.create([0x01234567, 0x89abcdef]),
                                // Config
                                { drop: 0 }
                            ).stringify()
                        );

                        Y.Assert.areEqual(
                            // Expected
                            C.lib.WordArray.create([0xdcee4cf9, 0x2c000000], 5).stringify(),
                            // Actual
                            C.RC4.decrypt(
                                // Ciphertext
                                C.cipher.formatter.OpenSSL.create(C.lib.WordArray.create([0xf13829c9, 0xde000000], 5)),
                                // Key
                                C.lib.WordArray.create([0x618a63d2, 0xfb000000], 5),
                                // Config
                                { drop: 0 }
                            ).stringify({ clamp: true })
                        );
                    }
                }));

                // Test runner
                Y.Test.Runner.add(cryptoJsTestSuite);

                new Y.Console({
                    style: 'block',
                    width: '600px',
                    height: '600px',
                    entryTemplate:
                      '<div class="{entry_class} {cat_class} {src_class}">' +
                      '    <p class="{entry_meta_class}">' +
                      '        <span class="{entry_cat_class}">{category}</span>' +
                      '    </p>' +
                      '    <pre class="{entry_content_class}">{message}</pre>' +
                      '</div>',
                    newestOnTop: false,
                    render: true
                });

                Y.Test.Runner.run();
            });
        </script>

        <style type="text/css">
            body.yui3-skin-sam .yui3-console-entry-meta,
            body.yui3-skin-sam .yui3-console-entry-content {
                display: inline-block;
                vertical-align: top;
            }
            body.yui3-skin-sam .yui3-console-entry-cat {
                display: inline-block;
                width: 35px;
                text-align: center;
            }
            body.yui3-skin-sam .yui3-console-entry {
                min-height: 0;
            }
        </style>
    </head>
    <body class="yui3-skin-sam">
    </body>
</html>
